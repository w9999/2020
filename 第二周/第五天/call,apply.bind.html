<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <button id="btn">点击</button>
    <script>
        // "use strict"  // 使用严格模式
        /* 
        call、apply、bind：他们Function原型上的方法

        而且每一个函数都是Function类的实例，所以他们的__proto__都指向Function的原型，所以说每一个函数都可以调用Function原型上的方法，
        (每一个函数都可以调用call、apply、bind这三个方法)
        他们三个的作用都是改变函数的this指向的
         */

        //  function fn(a,b){
        //      console.log(this,a,b) // obj
        //  }
        // //  fn();
        // let obj = {name:3};

         // 让fn执行，并且把fn的this指向obj

        //  obj.fn = fn;
        //  obj.fn(); //
        //  delete obj.fn 


        // fn.call(obj,1,2)//  让fn执行，并且把fn的this指向obj

        /* 
        当前fn作为对象的身份，找到当前所属类原型上的call方法,并且让call方法执行
        在call方法执行的时候给他传递实参
        当call方法执行的时候，call的内部执行了fn函数，并且让fn函数的this指向了call的第一个实参，然后从第二个实参开始，都是传递给fn执行时的参数(call方法里的this是fn)
         */
            // function fn(){
            //     console.log(this);
            // }
            // fn.call(1);

            /* 
            1、在严格模式下，如果call不传参或者传递undeinfed，那fn的this指向就是undefined，如果传递null，那fn的this指向就是null
            2、在非严格下，call不传参，或者传递undefined，或者传递null，那fn的this都是window
            3、除了上边的几种情况，那fn里的this你传递啥就是啥
             */
         //--------------------------------------

        //  apply：他和call的作用是一样的，都是改变this指向的，call的第二个实参必须是数组或者类数组,apply执行得时候会遍历数组，然后把数组的每一项给fn的形参依次赋值

        // function fn(a,b){
        //     console.log(this,a,b) // {name:1}, 1, 2
        // }
        // let obj = {name:1}
        // fn.apply(obj,[1,2])

        // Object.prototype.toString.call(1)

    //--------------------------------------------
    /* 
    bind：bind和call、apply的最终目的是一样的，都是改变函数的this指向的，bind是预处理this，他并不会让fn函数执行，bind方法的返回值是一个改变this之后的新函数
     */
    //  function fn(){
    //      console.log(this)
    //  }
    //  let obj = {name:1};
    // fn = fn.bind(obj);
    // fn()

    // btn.onclick = function(){
    //     console.log(this)
    // }
    // 把事件里的this改为window
    // function fn(){
    //     console.log(this)
    // }
    // btn.onclick = fn.bind(window);




    </script>
</body>
</html>